#!/usr/bin/env python3
import sys
import numpy as np
from itertools import product

def parse_input(C):
    M = np.zeros((8,8))
    for i, c in enumerate(C):
        for j, e in enumerate(c):
            M[i,j] = 0 if e=='.' else 1
    return M

def check_diag(M):
    for m in [M, np.fliplr(M)]:
        for i in range(-8, 8):
            if sum(np.diag(m, k=i)) > 1:
                return 'invalid'

    for i in range(8):
        if sum(M[i]) > 1 or sum(M[:, i]) >1 :
            return 'invalid'

    if M.sum() == 8:
        return 'solved'
                            
    return 'valid'

def parse_out(M):
    for line in M:
        row = ['.' if c == 0 else 'Q' for c in line]
        print(''.join(row))

def solve(c: "List[str]"):
    M = parse_input(c)

    if check_diag(M) == 'invalid':
        print('No Answer')
        return

    solved_M = solve2(M)

    if type(solved_M) == str:
        print(solved_M)
    else:
        parse_out(solved_M)
    return

def calculate_possible_ij(M):
    
    for i,j in zip(*np.where(M==1)):

        M[i, :] = 1 # rows = 1
        M[:, j] = 1 # cols = 1

        # create diagonal indices
        # First diagonal
        k = j - i
        row_idxs, col_idxs = np.indices((8,8)) 
        diag_i = np.diag(row_idxs, k=k)
        diag_j = np.diag(col_idxs, k=k)
        M[diag_i, diag_j] = 1

        # Second diagonal
        row_idxs, col_idxs = np.flipud(row_idxs), col_idxs 
        k = col_idxs[0, j] - row_idxs[i, 0]
        diag_i = np.diag(row_idxs, k=k)
        diag_j = np.diag(col_idxs, k=k)
        M[diag_i, diag_j] = 1

    return np.where(M==0)


def solve2(M, count=0):
    if count == 5:
        return M
    for i, j in zip(*calculate_possible_ij(M.copy())):
        new_M = M.copy()
        new_M[i,j] = 1
        ret = solve2(new_M, count+1)
        if type(ret)==np.ndarray: 
            return ret       
    return 'No Answer'
            
# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    c = [next(tokens) for _ in range(8)]  # type: "List[str]"
    solve(c)

if __name__ == '__main__':
    main()
