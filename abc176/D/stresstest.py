#!/usr/bin/env python3


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
import itertools as it
from collections import deque
from random import randint, seed

def solve_1(H, W, Ch, Cw, Dh, Dw, S):

    # visited[H][W]
    visited =  [[False for _ in range(W)] for __ in range(H)]

    # pick root 
    root = (Ch, Cw)
    
    # flag
    empty_while = True
    count = 0

    """DFS"""
    def DFS(node, block=set([])):
        def pick_next(node):
            h,w = node
            assert S[h][w]
            for next_h, next_w in [
                (h+1, w), # down
                (h, w+1), # right
                (h, w-1), # left
                (h-1, w)  # up
            ]:
                try:
                    if next_w < 0 or next_h < 0:
                        raise IndexError
                    if not visited[next_h][next_w]:
                        if S[next_h][next_w]:
                            return next_h, next_w
                except IndexError:
                    pass
            return False

        # mark root as traversed
        visited[node[0]][node[1]] = True
        block.add(node)

        # if there is a node to go to 
        while pick_next(node):
            next_node = pick_next(node)
            if node:
                # mark node as traversed
                h, w = next_node
                visited[h][w] = True
                block.add(next_node)

                # go to next node
                DFS(next_node, block)
        
        return frozenset(block)

    """BFS"""
    def BFS(node):
        def pick_next(node):
            h,w = node
            r = range(-2, 3)
            for h_offset, w_offset in it.product(r,r):
                next_h = h + h_offset
                next_w = w + w_offset
                try:
                    if next_w < 0 or next_h < 0:
                        raise IndexError
                    if not visited[next_h][next_w]:
                        if S[next_h][next_w]:
                            return next_h, next_w
                except IndexError:
                    pass
            return False

        queue = deque([])
        levels = {}

        start = DFS(node)
        if visited[Dh][Dw]: 
            return 0
        queue.append(start)  
        levels[start] = 0

        while queue:
            block = queue.popleft()
            
            if visited[Dh][Dw]:
                    return levels[next_block]

            for node in block:

                while pick_next(node):
                    next_node = pick_next(node)

                    # add node to queue
                    next_block = DFS(next_node, block=set([]))
                    queue.append(next_block)
                    levels[next_block] = levels[block] + 1


        return -1 

    node = root
    count = BFS(node)    
        
    print(count)
    return count

def solve_2(H, W, Ch, Cw, Dh, Dw, S):
    INF = 10 ** 6
    q = deque([(Ch,Cw)])
    a = 0
    t = S.copy()
    for i, j in it.product(range(H),range(W)):
        t[i][j] = INF if S[i][j] else -1
    t[Ch][Cw] = a

    while q:
        warpq = []
        while q:
            h,w = q.popleft()
            warpq.append((h,w))
            if 0 < h and t[h-1][w] > a:
                t[h-1][w] = a
                q.append((h-1,w))
            if H-1 > h and t[h+1][w] > a:
                t[h+1][w] = a
                q.append((h+1,w))
            if 0 < w and t[h][w-1] > a:
                t[h][w-1] = a
                q.append((h,w-1))
            if w < W-1 and t[h][w+1] > a:
                t[h][w+1] = a
                q.append((h,w+1))
 
        if t[Dh][Dw]!= INF:
            break
 
        a+=1
 
        for h,w in warpq:
            for i in range (max(0,h-2),min(H,h+3)):
                ti = t[i]
                for j in range (max(0,w-2),min(W,w+3)):
                    if ti[j] >a:
                        ti[j] = a
                        q.append((i,j))
 
 
    if t[Dh][Dw] == INF:
        print(-1)
        return -1
    else:
        print(t[Dh][Dw])
        return t[Dh][Dw]


if __name__ == '__main__':
    seed(0)
    while True:
        N = 1000
        H, W = randint(1, N),  randint(1, N)
        Ch, Cw = randint(1, H),  randint(1, W)
        Dh, Dw = randint(1, H),  randint(1, W)
        S = [['.' if randint(0, 1) else '#' for _ in range(W)] for __ in range(H)]
        S[Ch - 1][Cw - 1] = '.'
        S[Dh - 1][Dw - 1] = '.'

        print(H, W)
        print(Ch, Cw)
        print(Dh, Dw)


        Ch -= 1
        Cw -= 1
        Dh -= 1
        Dw -= 1

        for i, srow in enumerate(S):
            for j, s in enumerate(srow):
                if i ==Ch and j ==Cw:
                    print('S', end='')
                elif i==Dh and j ==Dw:
                    print('E', end='')
                else:
                    print(s, end='')
            print()

        for h in range(H):
            S_row = S[h]
            for w, s in enumerate(S_row):
                if s=='.':
                    S[h][w] = True
                else:
                    S[h][w] = False

        ans1 = solve_1(H, W, Ch, Cw, Dh, Dw, S)
        ans2 = solve_2(H, W, Ch, Cw, Dh, Dw, S)
        assert ans1 == ans2, f'{ans1} != {ans2}'